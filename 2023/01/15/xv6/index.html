

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/ljx.jpg">
  <link rel="icon" href="/img/ljx.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Jiaxin Lai">
  <meta name="keywords" content="个人">
  
    <meta name="description" content="初次复制之前的笔记，还未整理，先鸽  xv6-labs-2020 系统调用   kernel&#x2F;syscall.h：定义各系统调用的编号   user&#x2F;user.h：在用户态下声明所有的系统调用函数（新增系统调用时，需要在这里声明才能在程序中调用）、以及一些辅助函数的声明   user&#x2F;usys.pl：系统内核与用户程序的中间体 该脚本文件会在编译期间被执行，生成个汇编文件usys.S。其对每一个">
<meta property="og:type" content="article">
<meta property="og:title" content="xv6">
<meta property="og:url" content="https://lai-jx.github.io/2023/01/15/xv6/index.html">
<meta property="og:site_name" content="LJX的博客">
<meta property="og:description" content="初次复制之前的笔记，还未整理，先鸽  xv6-labs-2020 系统调用   kernel&#x2F;syscall.h：定义各系统调用的编号   user&#x2F;user.h：在用户态下声明所有的系统调用函数（新增系统调用时，需要在这里声明才能在程序中调用）、以及一些辅助函数的声明   user&#x2F;usys.pl：系统内核与用户程序的中间体 该脚本文件会在编译期间被执行，生成个汇编文件usys.S。其对每一个">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221002000302454.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221107213301776.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221107151125397.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221126165102082.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221217154829656.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/ed2dd5a8fadf4f21a65ae55635a378d1.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221206162936454.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221207143827786.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221207145255382.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221215141355827.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221215151646981.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221024160039840.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221216133907508.png">
<meta property="og:image" content="https://lai-jx.github.io/img/xv6/image-20221213112534209.png">
<meta property="article:published_time" content="2023-01-15T07:43:00.000Z">
<meta property="article:modified_time" content="2023-01-15T07:54:11.123Z">
<meta property="article:author" content="Jiaxin Lai">
<meta property="article:tag" content="labs">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lai-jx.github.io/img/xv6/image-20221002000302454.png">
  
  
  
  <title>xv6 - LJX的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lai-jx.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":100,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"tZBW2fQtUumAkCEJYeIJO61m-gzGzoHsz","app_key":"hG5UEcEbTizgregyCQDGNn72","server_url":"https://tzbw2fqt.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>LJX</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="xv6"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Jiaxin Lai
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-01-15 15:43" pubdate>
          2023年1月15日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          29k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          243 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">xv6</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>初次复制之前的笔记，还未整理，先鸽</p>
</blockquote>
<h1>xv6-labs-2020</h1>
<h2 id="系统调用">系统调用</h2>
<ul>
<li>
<p>kernel/syscall.h：<strong>定义各系统调用的编号</strong></p>
</li>
<li>
<p>user/user.h：在用户态下<strong>声明所有的系统调用函数</strong>（新增系统调用时，需要在这里声明才能在程序中调用）、以及一些辅助函数的声明</p>
</li>
<li>
<p>user/usys.pl：<strong>系统内核与用户程序的中间体</strong></p>
<p>该脚本文件会在编译期间被执行，生成个汇编文件<code>usys.S</code>。其对每一个系统调用抽象接口都生成了一个具体的现，叫做entry</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs perl"> <span class="hljs-number">1</span>  <span class="hljs-comment">#!/usr/bin/perl -w</span><br> <span class="hljs-number">2</span><br> <span class="hljs-number">3</span>  <span class="hljs-comment"># Generate usys.S, the stubs for syscalls.</span><br> <span class="hljs-number">4</span><br> <span class="hljs-number">5</span>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;# generated by usys.pl - do not edit\n&quot;</span>;<br> <span class="hljs-number">6</span><br> <span class="hljs-number">7</span>  <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;#include \&quot;kernel/syscall.h\&quot;\n&quot;</span>;<br> <span class="hljs-number">8</span><br> <span class="hljs-number">9</span>  <span class="hljs-function"><span class="hljs-keyword">sub</span> <span class="hljs-title">entry</span> </span>&#123;<br><span class="hljs-number">10</span>      <span class="hljs-keyword">my</span> $name = <span class="hljs-keyword">shift</span>;<br><span class="hljs-number">11</span>      <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;.global $name\n&quot;</span>;<br><span class="hljs-number">12</span>      <span class="hljs-keyword">print</span> <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;name&#125;</span>:\n&quot;</span>;<br><span class="hljs-number">13</span>      <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; li a7, SYS_<span class="hljs-subst">$&#123;name&#125;</span>\n&quot;</span>;<br><span class="hljs-number">14</span>      <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; ecall\n&quot;</span>;<br><span class="hljs-number">15</span>      <span class="hljs-keyword">print</span> <span class="hljs-string">&quot; ret\n&quot;</span>;<br><span class="hljs-number">16</span>  &#125;<br><span class="hljs-number">17</span><br><span class="hljs-number">18</span>  entry(<span class="hljs-string">&quot;fork&quot;</span>);<br><span class="hljs-number">19</span>  entry(<span class="hljs-string">&quot;exit&quot;</span>);<br></code></pre></td></tr></table></figure>
<ul>
<li>Makefile调用perl脚本user/usys.pl，它生成user/usys.S，即实际的系统调用存根，它使用RISC-V ecall指令转换到内核</li>
<li><code>li a7, SYS_$&#123;name&#125;\n</code>：将系统调用号 <code>SYS_$&#123;name&#125;</code>（来自<code>kernel/syscall.h</code>）传给RISC-V CPU上的<code>a7</code>寄存器，这样内核就可以过<code>a7</code>寄存器知道现在要处理的是什么系统调用。</li>
<li><code>ecall</code>：特殊指令，用来转入操作系统内核（ <strong>关键</strong> 指令）。</li>
<li><code>ret</code>：操作系统内核执行完后会返回到这里，执行ret就结束了用户看到系统调用，返回至用户程序。<br>
你可以在编译后阅读<code>user/usys.S</code>，将其与上述脚本对应以便更好地理解。</li>
</ul>
</li>
<li>
<p>在usys.S中执行ecall进入内核：相应执行uservec、usertrap、usertrapret、userret等函数，实现用户态和内核态的切换以及其中系统调用的实现</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/462538325">xv6的trap实现流程 - 知乎 (zhihu.com)</a></li>
</ul>
</li>
<li>
<p>kernel/sysproc.c：通过一个proc结构体新变量来实现一个新的系统调用，在这里面有所有的<strong>与进程有关的</strong>系统调用函数，但所有系统调用函数的参数均为空，来自用户空间的参数需要通过argint等函数来实现</p>
</li>
<li>
<p>kernel/syscall.c：<strong>各个系统调用的入口</strong>。管理各个系统调用，内核中调用系统调用的地方，syscall函数，可以检索来自用户空间的系统调用参数</p>
</li>
<li>
<p>kernel/proc.h：定义寄存器（上下文）、cpu、进程控制块proc、进程状态（属于proc的一部分）、<strong>trapframe</strong>（属于proc的一部分，用于保存和写入用户空间32个寄存器的值，实现系统调用的<strong>参数传递和返回值传递</strong>）</p>
<p><img src="/img/xv6/image-20221002000302454.png" srcset="/img/loading.gif" lazyload alt="image-20221002000302454"></p>
</li>
<li>
<p>kernel/proc.c：真正实现对进程的控制的地方，sysproc.c中的系统调用函数最终的实现也需要依靠这里的函数</p>
</li>
</ul>
<h2 id="内存管理">内存管理</h2>
<h3 id="一些函数">一些函数</h3>
<ul>
<li><code>PX(level,va)</code>：用于获取页号（相对于页表基地址是第几项），va为虚拟地址，level为页表级数</li>
<li><code>pte_t *walk(pagetable_t pagetable, uint64 va, int alloc)</code>
<ul>
<li>在指定的页表<code>pagetable</code>中逐级查找，查找虚拟地址<code>va</code>对应的物理地址，返回对应叶子页表的页表项的地址</li>
<li>若alloc非0，则查找过程中可以为不在内存中的页表开辟空间，但无法建立映射，即开辟的空间里面的页表项是空的</li>
</ul>
</li>
<li><strong><code>int mappages(pagetable_t pagetable, uint64 va, uint64 size, uint64 pa, int perm)</code></strong>
<ul>
<li>将基地址为va，大小为size的虚拟空间，映射到基地址为pa，大小为size的物理空间；</li>
<li>先调用walk函数，获取页表项的地址，进而根据物理地址填上页表项</li>
<li>返回0表示成功，返回-1表示失败</li>
</ul>
</li>
<li><code>uint64walkaddr(pagetable_t pagetable, uint64 va)</code>：在指定的用户页表中找虚拟地址对应的物理地址，如果页表不存在/映射不存在返回 0</li>
<li>kvminit：<strong>创建初始内核页表</strong>（开辟空间并建立映射）</li>
<li>kvminthart: <strong>为CPU设置satp寄存器，刷新TLB</strong></li>
<li><code>void kvmmap(uint64 va, uint64 pa, uint64 sz, int perm)</code>
<ul>
<li>对mappages的封装，采用的页表默认为内核页表</li>
</ul>
</li>
<li><code>uint64 kvmpa(uint64 va)</code>：在内核页表中找虚拟地址对应的物理地址，只在为 kstack 找物理地址的时候才需要用，因为其余为直接映射</li>
<li><code>void uvmunmap(pagetable_t pagetable, uint64 va, uint64 npages, int do_free)</code>: <strong>解除映射</strong>, Remove npages of mappings starting from va. va must be <strong>page-aligned</strong>(4k对齐). The mappings <strong>must exist</strong>.
<ul>
<li>若do_free不为零则会同时释放页表项指向的空间</li>
</ul>
</li>
<li><code>pagetable_t uvmcreate()</code>：创建一个新的用户页表，即为页表开辟空间；超出内存则返回0</li>
<li><code>void uvminit(pagetable_t pagetable, uchar *src, uint sz)</code>：为第一个进程加载页表；</li>
<li><code>uint64 uvmalloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)</code>：对一个增长的进程分配页表项（映射）和物理内存
<ul>
<li>如果 newsz &gt;= oldsz，则在 [oldsz, newsz) 区间内<strong>开辟内存、创建页表并建立映射</strong>。</li>
<li>Returns new size or 0 on error.</li>
</ul>
</li>
<li><code>uint64 uvmdealloc(pagetable_t pagetable, uint64 oldsz, uint64 newsz)</code>：如果 oldsz &gt; newsz，则将 [newsz, oldsz) 区间内的页表<strong>解除映射并释放页表项指向的空间</strong>；不需要4k对齐
<ul>
<li>返回newsz</li>
</ul>
</li>
<li><strong><code>void uvmfree(pagetable_t pagetable, uint64 sz)</code></strong>：<strong>解除映射、释放页表项指向的空间、释放页表本身</strong>；</li>
<li><code>int uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)</code>：把父进程的页表和页表项指向的物理空间复制给子进程；
<ul>
<li>用户虚拟地址空间从0开始</li>
</ul>
</li>
<li><code>void uvmclear(pagetable_t pagetable, uint64 va)</code>：把给一个 PTE 标志为 (对用户态失效)，系统调用 exec 用它来设置 guard pages。</li>
<li><code>int copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)</code>：
<ul>
<li>从内核 copy 给用户地址</li>
<li>根据pagetable和dstva查找用户物理地址，从src的复制len个字节到该物理地址</li>
<li>成功返回0，失败返回-1</li>
</ul>
</li>
<li><code>int copyin(pagetable_t pagetable, char *dst, uint64 srcva, uint64 len)</code>：从用户地址 copy 进内核
<ul>
<li>Copy len bytes to dst from virtual address srcva in a given page table.</li>
<li>Return 0 on success, -1 on error.</li>
</ul>
</li>
<li><code>int copyinstr(pagetable_t pagetable, char *dst, uint64 srcva, uint64 max)</code>：从用户地址 copy 一个字符串进内核
<ul>
<li>Copy bytes to dst from virtual address srcva in a given page table, until a ‘\0’, or max.</li>
<li>Return 0 on success, -1 on error.</li>
</ul>
</li>
<li><code>void freewalk(pagetable_t pagetable)</code>: 释放页表本身
<ul>
<li>Recursively（递归地） free page-table pages.</li>
<li>All leaf mappings must already have been removed.</li>
</ul>
</li>
</ul>
<h3 id="内核页表生命周期">内核页表生命周期</h3>
<p>为此，我们回顾一下全局内核页表的「生命周期」（这一段在 xv6 book 的 3.3 节有详细阐述）：kernel/main.c 中，main 函数首先调用 <strong>kvminit()</strong> 创建初始全局内核页表（开辟空间+填充初始页表项，除内核栈以外），然后调用 <strong>kvminithart()</strong> 装载全局内核页表，最后调用 <strong>procinit()</strong> 为所有 NPROC 个进程开辟内核栈并重新装载。由于全局内核页表是始终存在的，所以没有释放的操作。</p>
<ul>
<li>进程的最大数量为64，一开始便为这64个进程都分配了内核栈（虚拟地址和物理地址）</li>
</ul>
<h2 id="lab4-（Lab-page-tables）实现思路">lab4 （Lab: page tables）实现思路</h2>
<p>不要忘了我们的目的：</p>
<blockquote>
<p>共享内核页表中，所有物理地址都和与之完全相等的虚拟地址建立映射，也就是直接映射。这是让内核能够直接以物理地址访问内存的数据，不需要使用任何的虚拟地址。</p>
<p><strong>但是</strong> ，由于用户地址的映射并未存储于内核页表，如果我们需要处理用户程序传来的虚拟地址（比如系统调用传入的指针），我们需要先找到用户页表(<strong>存于进程控制块中</strong>)，逐个页表项地找到能够翻译对应虚拟地址的页表项后，才可以获取实际的物理地址并进行访问，这叫做软件模拟翻译。软件模拟翻译的实现很复杂，同时，因为需要复杂的查找，还降低了性能。</p>
<p>所以我们将 <em>用户页表中的内存映射</em> 和 <em>原来共享内核页表中的内存映射</em> 进行合并，这样内核也能够直接对用户的虚拟地址进行访问，而不需要软件模拟翻译。需要注意的是，这是 <strong>任务三和任务二一同</strong> 需要实现的结果，任务二分离出独立页表，任务三利用独立页表去除软件模拟翻译。</p>
</blockquote>
<h3 id="任务2：">任务2：</h3>
<ol>
<li>
<p>进程控制块结构体添加:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">pagetable_t</span> k_pagetable;<span class="hljs-comment">//独立内核页表</span><br>uint64 kstack_pa;		<span class="hljs-comment">//内核栈物理地址</span><br></code></pre></td></tr></table></figure>
</li>
<li>
<p>由于每个进程对应一个独立内核页表，故在allocproc声明进程控制块的同时初始化进程对应的<strong>独立内核页表</strong>（参考kvminit，但不要映射CLINT，对于kvminit内部的kvmmap，可以声明函数pvmmap替换，不能直接调用kvmmap，因为kvmmap的页表默认为共享内核页表）<br>
由于内核栈是在整个系统加载时分配空间的(只会分配一次，一次性为64个进程分配，每个进程的内核栈对应的虚拟地址就是在这时初始化的)，故还需将内核栈的虚拟地址和物理地址映射起来填入<strong>独立内核页表</strong>(参考mappages和kvmmap，可以使用之前声明的pvmmap)</p>
<p>(指导书说，要在procinit中将内核栈物理地址pa拷贝到PCB的成员kstack_pa，其实我不太理解为什么还要有kstack_pa，PCB已经有内核页表k_pagetable和内核虚拟地址kstac了，完全可以据此求出内核栈物理地址kstack_pa)</p>
</li>
<li>
<p>在进程使用前应先将内核空间的根页表的基地址放入SATP寄存器，之前是共享内核页表，只会放一次。而现在我们更改为独立内核页表，则对应页表需要伴随着进程的运行和终止，同步进行独立内核页表的<strong>装入和释放</strong></p>
<ol>
<li>
<p>在scheduler中进程装入cpu准备运行前参照kvminthart，将独立内核页表基地址<strong>载入</strong>，<strong>当进程执行完时，应将全局页表重新装入。</strong></p>
<blockquote>
<p><img src="/img/xv6/image-20221107213301776.png" srcset="/img/loading.gif" lazyload alt="image-20221107213301776"></p>
</blockquote>
</li>
<li>
<p>在freeproc中释放进程控制块时，也将k_pagetable<strong>释放</strong>（解除映射，释放页表对应空间，<strong>不能释放页表项指向的空间</strong>，可以参照freewalk函数进行修改）</p>
</li>
</ol>
</li>
<li>
<p>ets：</p>
<ul>
<li>vm.c新增函数记得在def.h声明</li>
<li>各个内核栈的物理地址和虚拟地址在初始化（procinit）时就已经有了，共享页表的映射也已经建立，而独立页表的映射需要等到进程载入cpu才建立</li>
</ul>
</li>
</ol>
<h3 id="任务3：">任务3：</h3>
<p>不要忘记目的</p>
<blockquote>
<p>xv6目前使用<code>kernel/vm.c</code>中的<code>copyin()/copyinstr()</code>将用户地址空间的数据拷贝至内核地址空间，它们通过软件模拟翻译的方式获取用户空间地址对应的物理地址，然后进行复制（详情见代码注释）。</p>
<p>任务目标：你需要 <strong>在独立内核页表加上用户地址空间的映射，同时将函数 <code>copyin()/copyinstr()</code> 中的软件模拟地址翻译改成直接访问</strong> ，使得内核能够不必花费大量时间，用软件模拟的方法一步一步遍历页表，而是直接利用硬件</p>
<h6 id="用户页表和内核页表合并的一个重要前提：地址不重合：">用户页表和内核页表合并的一个重要前提：地址不重合：</h6>
<img src="/img/xv6/image-20221107151125397.png" srcset="/img/loading.gif" lazyload alt="image-20221107151125397" style="zoom:50%;" />
<p>==用户虚拟地址不能超过内核最低的虚拟地址，即 PLIC==</p>
</blockquote>
<h4 id="实现步骤与指导书上的差不多：">实现步骤与指导书上的差不多：</h4>
<ol>
<li>
<p>写一个<code>XXX</code>函数把进程的用户页表映射到内核页表中，同时在defs.h中声明</p>
</li>
<li>
<p>用函数 <code>copyin_new()</code> （在 <code>kernel/vmcopyin.c</code>中定义）代替 <code>copyin()</code> （在 <code>kernel/vm.c</code>中定义）。确保程序 <strong>能运行</strong> 之后再用 <code>copyinstr_new()</code> 以代替 <code>copyinstr()</code>。</p>
<ul>
<li>可以将<code>copyin_new()</code> 和 <code>copyinstr_new()</code>在defs.h中声明，然后在<code>copyin()</code> 和<code>copyinstr()</code>将代码改为调用对应函数</li>
</ul>
</li>
<li>
<p>在独立内核页表加上用户页表的映射，以保证刚刚替换的新函数能够使用。注意独立内核页表的用户页表的映射的标志位的选择。标志位User一旦被设置，内核就不能访问该虚拟地址了</p>
<ul>
<li>
<p>两种实现方法：</p>
<p>（1）把内核页表中页表项的User位均置为0；</p>
<p>（2）借助RISC-V的<code>sstatus</code>寄存器，如果该寄存器的SUM位（第18位）置为1，那么内核也可以直接访问上述的虚拟地址。大多情况下，该位需要置0。</p>
</li>
<li>
<p>指导书推荐第二种：在调用copyin_new()/ copyinstr_new()之前修改sstatus寄存器的SUM位：<code>w_sstatus(r_sstatus() | SSTATUS_SUM);</code> 在凋用copyin_new()/ copyinstr_new()之后去掉sstatus寄存器的SUM位：<code>w_sstatus(r_sstatus() &amp; ~SSTATUS_SUM);</code></p>
<p><strong>注意</strong>：<code>SSTATUS_SUM</code>需在riscv.h中声明：<code>#define SSTATUS_SUM (1L &lt;&lt; 18) // Allow kernel to visit user's vitual address</code></p>
</li>
</ul>
</li>
<li>
<p>在fork()、exec()和growproc()这三个函数里将改变后的进程页表同步到内核页表中。</p>
<ol>
<li>fork：将父进程的页表复制一份给子进程，<strong>子进程的用户页表也要复制并形成独立内核页表</strong></li>
<li>exec：exec 和 fork 函数不同，exec 的函数原型是 <code>exec(BIN, argv...)</code>。exec 并不额外创建进程，<br>
而是在当前进程中直接执行对应的命令和函数。那么就要<strong>替换进程的内容</strong>。其中最重要的，就是替换新的地址空间及内容，用户页表改变，此时独立内核页表需要同步改变</li>
<li>growproc：随着进程的进行，有的函数执行完毕或者有新的函数执行，此时用户空间会随之增加或减少，用户页表改变，此时独立内核页表需要同步改变（解除映射但<strong>不释放页表项指向的空间</strong>）</li>
</ol>
</li>
<li>
<p>第一个进程也需要将用户页表映射到内核页表中，见kernel/proc.c: userinit()</p>
</li>
</ol>
<h2 id="Lab-traps">Lab traps</h2>
<ul>
<li>Which registers contain arguments to functions? For example, which register holds 13 in main’s call to <code>printf</code>?
<ul>
<li>由 <code>li a2,13</code> 和 <code>li a1,12</code>可知，<code>a1</code>和<code>a2</code>寄存器包含了传递给函数的参数，其中<code>a2</code>寄存器含有<code>main</code>函数传递给<code>printf</code>函数的参数<code>13</code></li>
</ul>
</li>
<li>Where is the call to function <code>f</code> in the assembly code for main? Where is the call to <code>g</code>? (Hint: the compiler may inline functions.)
<ul>
<li>汇编程序中没有直接调用函数<code>f</code>的代码，由<code>li a1,12</code>可知函数<code>f(8)+1</code>的结果直接被计算出来了，说明编译器进行了内联；同时函数<code>g</code>的代码和<code>f</code>一样，说明也进行了内联</li>
</ul>
</li>
<li>At what address is the function <code>printf</code> located?
<ul>
<li>由指令<code>jalr 1528(ra) # 628 &lt;printf&gt;</code>可知，函数<code>printf</code>的地址为<code>0x628</code>  (和之前不太一样？之前是630)</li>
</ul>
</li>
<li>What value is in the register <code>ra</code> just after the <code>jalr</code> to <code>printf</code> in <code>main</code>?
<ul>
<li><code>jalr</code> 会将 pc+4 存储给指定的寄存器 ra，所以 ra=<code>0x38</code>。</li>
</ul>
</li>
<li>Run the following code.</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs perl">unsigned <span class="hljs-keyword">int</span> i = <span class="hljs-number">0x00646c72</span>;<br><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;H%x Wo%s&quot;</span>, <span class="hljs-number">57616</span>, &amp;i);<br>     <br></code></pre></td></tr></table></figure>
<p>What is the output? <a target="_blank" rel="noopener" href="http://web.cs.mun.ca/~michael/c/ascii-table.html">Here’s an ASCII table</a> that maps bytes to characters.</p>
<p>The output depends on that fact that the RISC-V is little-endian. If the RISC-V were instead big-endian what would you set <code>i</code> to in order to yield the same output? Would you need to change <code>57616</code> to a different value?</p>
<p><a target="_blank" rel="noopener" href="http://www.webopedia.com/TERM/b/big_endian.html">Here’s a description of little- and big-endian</a> and <a target="_blank" rel="noopener" href="http://www.networksorcery.com/enp/ien/ien137.txt">a more whimsical description</a>.</p>
<p>输出为<code>He110 World</code>，<code>%x</code>表示以十六进制进行输出，<code>57616</code>对应的16进制为<code>e110</code>，结合前面的<code>H</code>便形成<code>He110</code>；在ASCALL码中<code>0x64</code>对应<code>d</code>，<code>0x6d</code>对应<code>l</code>，<code>0x72</code>对应<code>r</code>，由于RIAC-V采用的是小端对齐，所以会依次读出<code>0x72(r)</code>、<code>0x6d(l)</code>、<code>0x64(d)</code>，结合前面的<code>Wo</code>形成<code>World</code></p>
<p>如果采用大端对齐，<code>57616</code>不用改变，<code>0x00646c72</code>需改为<code>0x726c6400</code></p>
<ul>
<li>In the following code, what is going to be printed after <code>'y='</code>? (note: the answer is not a specific value.) Why does this happen?</li>
</ul>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">printf</span>(<span class="hljs-string">&quot;x=%d y=%d&quot;</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>
<p>y对应的是寄存器a2的值，由于没有提前给a2赋值，所以这个值是不确定的</p>
<h3 id="backtrace">backtrace</h3>
<p><img src="/img/xv6/image-20221126165102082.png" srcset="/img/loading.gif" lazyload alt="image-20221126165102082"></p>
<h3 id="Alarm">Alarm</h3>
<h5 id="1">(1)</h5>
<p>在本练习中，您将向 xv6添加一个特性，该特性会在进程使用 CPU 时间时定期发出警报。这对于希望限制占用 CPU 时间的计算绑定进程或希望进行计算但也希望采取某些周期性操作的进程可能很有用。更一般地说，您将实现用户级中断/错误处理程序的基本形式; 例如，您可以使用类似的东西来处理应用程序中的页面错误。如果您的解决方案通过了警报测试和用户测试，那么它就是正确的。</p>
<p>您应该添加一个新的信号警报(间隔、处理程序)系统调用。如果应用程序调用 sigAlarm (n，fn) ，那么在程序消耗的每 n 个 CPU 时间之后，内核应该调用应用程序函数 fn。当 fn 返回时，应用程序应该从停止的地方恢复。在 xv6中，clock是一个相当任意的时间单位，由硬件计时器生成中断的频率决定。如果一个应用程序调用 sigAlarm (0,0) ，内核应该停止生成周期性的警报调用。</p>
<p><a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/traps.html">xv6的指导书非常详细</a></p>
<h5 id="2">(2)</h5>
<p>在完成test0之后，其实忽略了一个重要的问题，报出alarm之后，应该恢复上下文寄存器，继续执行时钟中断前的指令</p>
<p><strong>实现方法：</strong></p>
<ul>
<li>可以在满足ticks数后，在usertrap将整个p-&gt;trapframe保存起来（在proc中添加成员save_trapframe）；</li>
<li>执行系统调用sigreturn时再进行恢复trapframe；同时释放save_trapframe</li>
<li>注意：为了防止重复进入handler，需要在usertrap进行操作前判断save_trapframe是否为0，若不是则说明有handle函数正在执行</li>
</ul>
<p><img src="/img/xv6/image-20221217154829656.png" srcset="/img/loading.gif" lazyload alt="image-20221217154829656"></p>
<h2 id="Lab-Lazy">Lab Lazy</h2>
<p>O/S 可以对页表硬件使用的许多巧妙技巧之一是用户空间堆内存的惰性分配。Xv6应用程序使用 sbrk ()系统调用请求内核提供堆内存。在我们提供的内核中，sbrk ()分配物理内存并将其映射到进程的虚拟地址空间。内核为大型请求分配和映射内存可能需要很长时间。例如，假设一个 GB 包含262,144个4096字节的页面; 这是一个巨大的分配数量，即使每个页面都很小。此外，有些程序分配的内存比实际使用的要多(例如，实现稀疏数组) ，或者在使用之前很早就分配了内存。为了让 sbrk ()在这种情况下能够更快地完成，复杂的内核会延迟地分配用户内存。也就是说，sbrk ()不分配物理内存，只是记住分配了哪些用户地址，并在用户页表中将这些地址标记为无效。当进程首次尝试使用任何给定的延迟分配内存页面时，CPU 会生成一个页面错误，内核通过分配物理内存、对其用0填充并映射来处理该错误。您将在这个实验中向 xv6添加这个惰性分配特性。</p>
<h3 id="1-Eliminate-allocation-from-sbrk-easy">1. Eliminate allocation from sbrk() (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">easy</a>)</h3>
<blockquote>
<p>消除来自sbrk()的分配</p>
<p>Your first task is to delete page allocation from the sbrk(n) system call implementation, which is the function sys_sbrk() in sysproc.c. The sbrk(n) system call grows the process’s memory size by n bytes, and then returns the start of the newly allocated region (i.e., the old size). Your new sbrk(n) should just increment the process’s size (myproc()-&gt;sz) by n and return the old size. It should not allocate memory – so you should delete the call to growproc() (but you still need to increase the process’s size!).</p>
<p>简单说，就是sys_sbrk()函数中只声明大小，而不实际分配空间</p>
</blockquote>
<h3 id="2-Lazy-allocation-moderate">2. Lazy allocation (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3>
<p>Modify the code in trap.c to respond to a page fault from user space by mapping a newly-allocated page of physical memory at the faulting address, and then returning back to user space to let the process continue executing. You should add your code just before the <code>printf</code> call that produced the “usertrap(): …” message. Modify whatever other xv6 kernel code you need to in order to get <code>echo hi</code> to work.</p>
<p>Here are some hints:</p>
<ul>
<li>You can check whether a fault is a page fault by seeing if r_scause() is 13 or 15 in usertrap().</li>
<li><code>r_stval()</code> returns the RISC-V <code>stval</code> register, which contains the virtual address that caused the page fault.</li>
<li>Steal code from uvmalloc() in vm.c, which is what sbrk() calls (via growproc()). You’ll need to call kalloc() and mappages().</li>
<li>Use PGROUNDDOWN(va) to round the faulting virtual address down to a page boundary.</li>
<li>uvmunmap() will panic; modify it to not panic if some pages aren’t mapped.
<ul>
<li>还需要更改 uvmunmap 的内容，这是因为加入懒分配之后，uvmunmap 可能会被要求解除本就不存在的映射、或者去找还没有创建的 pte。在原本的写法中这样会 panic，因此，我们要把 panic 改掉</li>
</ul>
</li>
</ul>
<p>If all goes well, your lazy allocation code should result in <code>echo hi</code> working. You should get at least one page fault (and thus lazy allocation), and perhaps two.</p>
<h3 id="3-Lazytests-and-Usertests-moderate">3. Lazytests and Usertests (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">moderate</a>)</h3>
<p>完成2之后任务远没完成</p>
<p>We’ve supplied you with <code>lazytests</code>, an xv6 user program that tests some specific situations that may stress your lazy memory allocator. Modify your kernel code so that all of both <code>lazytests</code> and <code>usertests</code> pass.</p>
<ol>
<li>Handle negative sbrk() arguments. （处理负的sbrk()参数）
<ul>
<li>解除映射（参照growproc()）</li>
</ul>
</li>
<li>Kill a process if it page-faults on a virtual memory address higher than any allocated with sbrk().（如果缺页错误的虚拟地址高于任何sbrk()分配的内存地址，则杀死进程）
<ul>
<li>va需要小于p-&gt;sz</li>
</ul>
</li>
<li>Handle the parent-to-child memory copy in fork() correctly.（在fork()中正确处理父进程到子进程的内存复制）</li>
<li>Handle the case in which a process passes a valid address from sbrk() to a system call such as read or write, but the memory for that address has not yet been allocated.（系统调用时，地址有效，但内存还没被分配）
<ul>
<li>trap发生的三种情况：系统调用、中断、异常；在惰性分配中，我们目前只考虑了缺页异常的情况，并在缺页时分配空间，但是，系统调用时也可能遇到未分配空间的情况，故也需要在系统调用时考虑内存是否已分配，若未分配，则需同之前一样进行分配空间。</li>
<li><code>uint64 walkaddr(pagetable_t pagetable, uint64 va)</code>：在指定的用户页表中找虚拟地址对应的物理地址，如果页表不存在/映射不存在返回 0</li>
</ul>
</li>
<li>Handle out-of-memory correctly: if kalloc() fails in the page fault handler, kill the current process.（正常处理内存溢出情况：kalloc()失败，则杀死当前进程）</li>
<li>Handle faults on the invalid page below the user stack.（处理缺页错误中访问用户栈下的非法空间）
<ul>
<li>va必须大于p-&gt;trapframe-&gt;sp（如下）</li>
<li><img src="/img/xv6/ed2dd5a8fadf4f21a65ae55635a378d1.png" srcset="/img/loading.gif" lazyload alt="在这里插入图片描述"></li>
<li>实际上，在本次实验中，<strong>我们关注的是heap的惰性分配</strong>，这也是为什么在上面第3点要求中，不能直接在fork内将uvmcopy给注释掉</li>
</ul>
</li>
</ol>
<h2 id="Lab-COW">Lab COW</h2>
<p>虚拟内存提供了一定程度的间接性: 内核可以通过将 PTE 标记为无效或只读来拦截内存引用，从而导致页错误，并且可以通过修改 PTE 来更改地址的含义。在计算机系统中有这样一种说法: 任何系统问题都可以通过一定程度的间接来解决。惰性分配实验提供了一个例子。本次实验中我们尝试另一个例子: copy-on write fork</p>
<h3 id="problem">problem</h3>
<p>Xv6中的 fork ()系统调用将父进程的所有用户空间内存复制到子进程中。如果父进程很大，复制可能需要很长时间。更糟糕的是，这些工作通常被大量浪费; 例如，子代中的 fork ()后跟 exec ()将导致子代丢弃复制的内存，而且可能从未使用过大部分内存。另一方面，如果父级和子级都使用一个页面，并且其中一个或两个都写入该页面，则确实需要一个副本。</p>
<p>写时复制(copy-on-write，COW) fork ()的目标是将分配和复制子内存页的时间推迟到实际需要复制的时候(如果需要的话)。</p>
<p>COW fork ()只为子级创建一个页表，用于用户内存的 PTE 指向父级的物理页面。COW fork ()将父级和子级中的所有用户 PTE 都标记为不可写。当任何一个进程尝试编写这些 COW 页面中的一个时，CPU 将强制出现页面错误。内核页面错误处理程序检测到这种情况，为错误进程分配一个物理内存页面，将原始页面复制到新页面，并在错误进程中修改相关的 PTE 以引用新页面，这一次 PTE 标记为可写。当页面错误处理程序返回时，用户进程将能够编写这个复制过来的页面。</p>
<p>COW fork ()使得释放实现用户内存的物理页变得有点棘手。给定的物理页可以由多个进程的页表引用，并且只有在最后一个引用消失时才应该释放。</p>
<h3 id="test">test</h3>
<p>To help you test your implementation, we’ve provided an xv6 program called cowtest (source in user/cowtest.c). cowtest runs various tests, but even the first will fail on unmodified xv6. Thus, initially, you will see:</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>cowtest<br><span class="hljs-symbol">simple:</span> fork() failed<br><span class="hljs-variable">$ </span><br></code></pre></td></tr></table></figure>
<p><strong>The “simple” test allocates ==more than half of available physical memory==, and then fork()s. The fork fails because there is not enough free physical memory to give the child a complete copy of the parent’s memory.</strong></p>
<p>When you are done, your kernel should pass all the tests in both cowtest and usertests. That is:</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">$ cowtest<br>simple: ok<br>simple: ok<br>three: zombie!<br>ok<br>three: zombie!<br>ok<br>three: zombie!<br>ok<br>file: ok<br>ALL COW TESTS PASSED<br>$ usertests<br>...<br>ALL TESTS PASSED<br>$<br></code></pre></td></tr></table></figure>
<h3 id="Implement-copy-on-write-hard">Implement copy-on write(<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">hard</a>)</h3>
<p>Here’s a reasonable plan of attack.</p>
<ol>
<li>
<p>Modify uvmcopy() to map the parent’s physical pages into the child, instead of allocating new pages. Clear <code>PTE_W</code> in the PTEs of both child and parent.</p>
</li>
<li>
<p>Modify usertrap() to recognize page faults. When a page-fault occurs on a COW page, allocate a new page with kalloc(), copy the old page to the new page, and install the new page in the PTE with <code>PTE_W</code> set.</p>
<ul>
<li>分配物理页</li>
<li>复制内容, 更新页表项</li>
<li>修改PTE_W和PTE_COW，释放原本的pa</li>
</ul>
</li>
<li>
<p>Ensure that each physical page is freed when the last PTE reference to it goes away – but not before. A good way to do this is to keep, for each physical page, a “reference count” of the number of user page tables that refer to that page. Set a page’s reference count to one when <code>kalloc()</code> allocates it. Increment a page’s reference count when fork causes a child to share the page, and decrement a page’s count each time any process drops the page from its page table. <code>kfree()</code> should only place a page back on the free list if its reference count is zero. It’s OK to to keep these counts in a fixed-size array of integers. You’ll have to work out a scheme for how to index the array and how to choose its size. For example, you could index the array with the page’s physical address divided by 4096, and give the array a number of elements equal to highest physical address of any page placed on the free list by <code>kinit()</code> in kalloc.c.</p>
<ul>
<li>为了判断何时回收物理页，需要一个应用计数（以下用count表示），当kalloc()时，count置一；当fork时，count++；当页面从页表销毁时，count–；只有count=0，kfree()才将页面放到空闲链表中</li>
<li>例如，您可以使用页面的物理地址除以4096来索引数组，并在 kalloc.c 中通过 kinit ()初始化数组</li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a9d7c6960ee7">xv6中内核物理内存占用区间</a>：KERNBASE 指的是物理内存的起始地址， PHYSTOP 是 xv6 的物理内存终止地址</li>
</ul>
</li>
<li>
<p>Modify copyout() to use the same scheme as page faults when it encounters a COW page.</p>
</li>
</ol>
<p>Some hints:</p>
<ul>
<li>
<p>The lazy page allocation lab has likely made you familiar with much of the xv6 kernel code that’s relevant for copy-on-write. However, you should not base this lab on your lazy allocation solution; instead, please start with a fresh copy of xv6 as directed above.</p>
</li>
<li>
<p>It may be useful to have a way to record, for each PTE, whether it is a COW mapping. You can use the RSW (reserved for software) bits in the RISC-V PTE for this.</p>
<ul>
<li>使用 RISC-V PTE 中的 RSW（保留位）来标志PTE是否为COW映射</li>
<li><img src="/img/xv6/image-20221206162936454.png" srcset="/img/loading.gif" lazyload alt="image-20221206162936454"></li>
</ul>
</li>
<li>
<p><code>usertests</code> explores scenarios that <code>cowtest</code> does not test, so don’t forget to check that all tests pass for both.</p>
</li>
<li>
<p>Some helpful macros and definitions for page table flags are at the end of <code>kernel/riscv.h</code>.</p>
</li>
<li>
<p>If a COW page fault occurs and there’s no free memory, the process should be killed.</p>
</li>
<li>
<p>etc：两个大坑，耗费了我很长时间，严重怀疑自己</p>
<ul>
<li>
<p>在cow分配页面后记得修改pte</p>
</li>
<li>
<p>我们只需对写页面错误进行处理，即在trap中只需判断<code>r_scause() == 15</code>，而无需判断是否等于13（这与lazy allocation不同，不要画蛇添足），虽然关系不大</p>
<img src="/img/xv6/image-20221207143827786.png" srcset="/img/loading.gif" lazyload alt="image-20221207143827786" style="zoom: 67%;" />
</li>
<li>
<p>在用锁的时候要特别特别注意。出现一些玄学操作往往都是锁的问题</p>
</li>
</ul>
</li>
</ul>
<p><img src="/img/xv6/image-20221207145255382.png" srcset="/img/loading.gif" lazyload alt="image-20221207145255382"></p>
<h2 id="Lab-Multithreading">Lab: Multithreading</h2>
<p>In this exercise you will design the context switch mechanism for a user-level threading system, and then implement it. To get you started, your xv6 has two files <code>user/uthread.c</code> and <code>user/uthread_switch.S</code>, and a rule in the Makefile to build a uthread program. uthread.c contains most of a user-level threading package, and code for three simple test threads. The threading package is missing some of the code to create a thread and to switch between threads.</p>
<p>简单说，就是实现用户级多线程，提出一个创建线程和保存/恢复寄存器的方法，以便在线程之间切换</p>
<h3 id="1-Uthread-switching-between-threads-moderate">1. Uthread: switching between threads (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)</h3>
<p>基本上就是仿照内核中的上下文切换</p>
<ul>
<li>和内核中进程调度一样，定义一个context，包含ra、sp、和各种被调用者需要保存的寄存器</li>
<li>将kernel/swtch.S的内容复制到user/uthread_switch.S</li>
<li>在thread_schefule()中调用uthread_switch进行上下文切换，从而实现线程切换</li>
<li>在thread_create()中将传入的函数指针赋值给ra，这样就可以在进程被调度时执行指定函数。把栈指针赋值到sp，由于<strong>栈空间是从大到小的</strong>，所以赋值的应该是栈的末尾指针</li>
</ul>
<h3 id="2-Using-threads-moderate">2. Using threads (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)</h3>
<ul>
<li>
<p>问题：The file <code>notxv6/ph.c</code> contains a simple hash table that is correct if used from a single thread, but incorrect when used from multiple threads</p>
</li>
<li>
<p>编译和运行：这里用的不是xv6，而是远程平台上的gcc</p>
<ul>
<li>
<pre><code class="language-sh">$ make ph
$ ./ph 1	# 数字表示线程数
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><br>- 简单来说就是多线程读写出现不同步，需要利用UNIX pthread的线程库加锁<br><br>  - ```c<br>    pthread_mutex_t <span class="hljs-keyword">lock</span>;            // <span class="hljs-keyword">declare</span> a <span class="hljs-keyword">lock</span><br>    pthread_mutex_init(&amp;<span class="hljs-keyword">lock</span>, <span class="hljs-keyword">NULL</span>); // initialize the <span class="hljs-keyword">lock</span><br>    pthread_mutex_lock(&amp;<span class="hljs-keyword">lock</span>);       // acquire <span class="hljs-keyword">lock</span><br>    pthread_mutex_unlock(&amp;<span class="hljs-keyword">lock</span>);     // <span class="hljs-keyword">release</span> <span class="hljs-keyword">lock</span><br></code></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
</li>
<li>
<p>哈希桶：There are situations where concurrent <code>put()</code>s have no overlap(重叠) in the memory they read or write in the hash table, and thus don’t need a lock to protect against each other. Can you change <code>ph.c</code> to take advantage of such situations to obtain parallel speedup for some <code>put()</code>s?==Hint: how about a lock per hash bucket?==</p>
</li>
</ul>
<h3 id="3-Barrier-moderate">3. Barrier(<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)</h3>
<ul>
<li>
<p>问题：将所有线程堵到一个点，我们期望所有线程都调用了 barrier() 之后才能继续执行。：In this assignment you’ll implement a <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Barrier_(computer_science)">barrier</a>: a point in an application at which all participating threads must wait until all other participating threads reach that point too. You’ll use pthread condition variables, which are a sequence coordination technique similar to xv6’s sleep and wakeup.</p>
</li>
<li>
<p>编译和运行：同2</p>
</li>
<li>
<p>更多线程库接口</p>
<ul>
<li>
<pre><code class="language-c">pthread_cond_wait(&amp;cond, &amp;mutex);  // go to sleep on cond, releasing lock mutex, acquiring upon wake up
// wait 中进入后release lock mutex，出来前acquire lock mutex的原因就是，要保证该进程可被唤醒
pthread_cond_broadcast(&amp;cond);     // wake up every thread sleeping on cond
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><br>- There are two issues <span class="hljs-keyword">that</span> complicate your task:<br><br>  - You have <span class="hljs-keyword">to</span> deal <span class="hljs-keyword">with</span> a succession <span class="hljs-keyword">of</span> barrier calls, each <span class="hljs-keyword">of</span> which we&#x27;ll call a <span class="hljs-built_in">round</span>. `bstate.<span class="hljs-built_in">round</span>` records <span class="hljs-keyword">the</span> current <span class="hljs-built_in">round</span>. You should increment `bstate.<span class="hljs-built_in">round</span>` each <span class="hljs-built_in">time</span> all threads have reached <span class="hljs-keyword">the</span> barrier.（所有进程到达barrier时，增加<span class="hljs-built_in">round</span>）<br>  - You have <span class="hljs-keyword">to</span> handle <span class="hljs-keyword">the</span> case <span class="hljs-keyword">in</span> which one thread races <span class="hljs-keyword">around</span> <span class="hljs-keyword">the</span> loop <span class="hljs-keyword">before</span> <span class="hljs-keyword">the</span> others have exited <span class="hljs-keyword">the</span> barrier. In particular, you are re-using <span class="hljs-keyword">the</span> `bstate.nthread` variable <span class="hljs-keyword">from</span> one <span class="hljs-built_in">round</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> next. Make sure <span class="hljs-keyword">that</span> a thread <span class="hljs-keyword">that</span> leaves <span class="hljs-keyword">the</span> barrier <span class="hljs-keyword">and</span> races <span class="hljs-keyword">around</span> <span class="hljs-keyword">the</span> loop doesn&#x27;t increase `bstate.nthread` <span class="hljs-keyword">while</span> a previous <span class="hljs-built_in">round</span> <span class="hljs-keyword">is</span> still using <span class="hljs-keyword">it</span>.（barrier.nthread要记得更新）<br><br>![image<span class="hljs-number">-20221213164316684</span>](/img/xv6/image<span class="hljs-number">-20221213164316684.</span>png)<br><br><span class="hljs-comment">## Lab fs</span><br><br><span class="hljs-comment">### 前置知识：</span><br><br>![image<span class="hljs-number">-20221213202906528</span>](/img/xv6/image<span class="hljs-number">-20221213202906528.</span>png)<br><br>- <span class="hljs-built_in">log</span><br><br>  - xv6 通过简单的日志系统来解决文件操作过程当中崩溃所导致的问题。一个系统调用并不直接导致对磁盘上文件系统的写操作，相反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写入了日志，它就会写一个特殊的提交记录到磁盘上，代表一次完整的操作。从那时起，系统调用就会把日志中的数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。<br><br>    为什么日志可以解决文件系统操作中出现的崩溃呢？如果崩溃发生在操作提交之前，那么磁盘上的日志文件就不会被标记为已完成，恢复系统的代码就会忽视它，磁盘的状态正如这个操作从未执行过一样。如果是在操作提交之后崩溃的，恢复程序会重演所有的写操作，可能会重复之前已经进行了的对磁盘文件系统的写操作。==在任何一种情况下，日志文件都使得磁盘操作对于系统崩溃来说是原子操作：在恢复之后，要么所有的写操作都完成了，要么一个写操作都没有完成。==<br><br>  - 组成<span class="hljs-built_in">log</span> 分为头快和<span class="hljs-built_in">log</span>块，头快包含各<span class="hljs-built_in">log</span>块的信息<br><br>- inode<br><br>  - ![img](/img/xv6/p2.png)<br><br>    存在直接索引和一级索引。inode结构体中的addr有<span class="hljs-number">13</span>个元素（包含<span class="hljs-number">12</span>个直接索引和一个简介所以）<br><br>  - [操作inode](<span class="hljs-comment">#操作inode的过程)</span><br><br>- 目录：<br><br>  - 目录项dirent：包含一个名称`<span class="hljs-built_in">name</span>`和一个inode编号`inum`，inode编号为零的条目是空的。<br><br>  - 函数`dirlookup`（***kernel/fs.c\***:<span class="hljs-number">527</span>）`struct inode* dirlookup(struct inode *dp, char *<span class="hljs-built_in">name</span>, uint *poff)`<br><br>    在目录中搜索具有给定名称的条目。如果找到一个，它将返回一个指向相应inode的指针，解开锁定，并将`*poff`设置为目录中条目的字节偏移量，以满足调用方希望对其进行编辑的情形。<br><br>  - 函数`dirlink`（***kernel/fs.c\***:<span class="hljs-number">554</span>）`dirlink(struct inode *dp, char *<span class="hljs-built_in">name</span>, uint inum)`<br><br>    将给定名称和inode编号的新目录条目写入目录`dp`<br><br>- 文件<br><br>  - 三种类型：管道、inode、设备<br>  - 系统中所有打开的文件都保存在全局文件表`ftable`中<br>  - 读取和写入偏移量以原子方式更新（上锁之后写入之前更新文件偏移量），因此，对同一文件的同时多次写入不能覆盖彼此的数据，尽管他们的写入最终可能是交错的<br><br><br><span class="hljs-comment">### 1. Large files ([moderate](https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html))</span><br><br>- 问题：In this assignment you&#x27;ll increase <span class="hljs-keyword">the</span> maximum size <span class="hljs-keyword">of</span> an xv6 <span class="hljs-built_in">file</span>. Currently xv6 files are limited <span class="hljs-keyword">to</span> <span class="hljs-number">268</span> blocks, <span class="hljs-keyword">or</span> <span class="hljs-number">268</span>*BSIZE bytes (BSIZE <span class="hljs-keyword">is</span> <span class="hljs-number">1024</span> <span class="hljs-keyword">in</span> xv6). This limit comes <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> fact <span class="hljs-keyword">that</span> an xv6 inode <span class="hljs-keyword">contains</span> <span class="hljs-number">12</span> <span class="hljs-string">&quot;direct&quot;</span> block numbers <span class="hljs-keyword">and</span> one <span class="hljs-string">&quot;singly-indirect&quot;</span> block <span class="hljs-built_in">number</span>, which refers <span class="hljs-keyword">to</span> a block <span class="hljs-keyword">that</span> holds up <span class="hljs-keyword">to</span> <span class="hljs-number">256</span> more block numbers, <span class="hljs-keyword">for</span> a total <span class="hljs-keyword">of</span> <span class="hljs-number">12</span>+<span class="hljs-number">256</span>=<span class="hljs-number">268</span> blocks.（原本直接索引+间接索引只有<span class="hljs-number">268</span>块，现在要增加）<br><br>- 任务：You&#x27;ll change <span class="hljs-keyword">the</span> xv6 <span class="hljs-built_in">file</span> system code <span class="hljs-keyword">to</span> support a <span class="hljs-string">&quot;doubly-indirect&quot;</span> block <span class="hljs-keyword">in</span> each inode, containing <span class="hljs-number">256</span> addresses <span class="hljs-keyword">of</span> singly-indirect blocks, each <span class="hljs-keyword">of</span> which can <span class="hljs-keyword">contain</span> up <span class="hljs-keyword">to</span> <span class="hljs-number">256</span> addresses <span class="hljs-keyword">of</span> data blocks. The <span class="hljs-literal">result</span> will be <span class="hljs-keyword">that</span> a <span class="hljs-built_in">file</span> will be able <span class="hljs-keyword">to</span> consist <span class="hljs-keyword">of</span> up <span class="hljs-keyword">to</span> <span class="hljs-number">65803</span> blocks, <span class="hljs-keyword">or</span> <span class="hljs-number">256</span>*<span class="hljs-number">256</span>+<span class="hljs-number">256</span>+<span class="hljs-number">11</span> blocks (<span class="hljs-number">11</span> <span class="hljs-keyword">instead of</span> <span class="hljs-number">12</span>, because we will sacrifice one <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> direct block numbers <span class="hljs-keyword">for</span> <span class="hljs-keyword">the</span> double-indirect block). （原本是直接索引+间接索引；现在改为直接索引+一级索引+二级索引）<br><br>  大小变为：<span class="hljs-number">256</span>*<span class="hljs-number">256</span>+<span class="hljs-number">256</span>+<span class="hljs-number">11</span>=<span class="hljs-number">65803</span>块<br><br>- mkfs<br><br>  The `mkfs` program creates <span class="hljs-keyword">the</span> xv6 <span class="hljs-built_in">file</span> system disk image <span class="hljs-keyword">and</span> determines how many total blocks <span class="hljs-keyword">the</span> <span class="hljs-built_in">file</span> system has; this size <span class="hljs-keyword">is</span> controlled <span class="hljs-keyword">by</span> `FSSIZE` <span class="hljs-keyword">in</span> `kernel/param.h`. You&#x27;ll see <span class="hljs-keyword">that</span> `FSSIZE` <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> repository <span class="hljs-keyword">for</span> this lab <span class="hljs-keyword">is</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">to</span> <span class="hljs-number">200</span>,<span class="hljs-number">000</span> blocks. You should see <span class="hljs-keyword">the</span> following output <span class="hljs-keyword">from</span> `mkfs/mkfs` <span class="hljs-keyword">in</span> <span class="hljs-keyword">the</span> make output:<br><br>  ```sh<br>  nmeta <span class="hljs-number">70</span> (boot, super, <span class="hljs-built_in">log</span> blocks <span class="hljs-number">30</span> inode blocks <span class="hljs-number">13</span>, bitmap blocks <span class="hljs-number">25</span>) blocks <span class="hljs-number">199930</span> total <span class="hljs-number">200000</span><br></code></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p>这一行描述了 mkfs/mkfs 构建的文件系统: 它有70个元数据块(用于描述文件系统的块)和199,930个数据块，总共200,000个块。如果在实验中的任何时候，您发现自己必须从头重新构建文件系统，那么可以运行 make clean 命令来重新构建 fs.img。</p>
</li>
<li>
<p>Hints</p>
<ul>
<li>Make sure you understand <code>bmap()</code>. Write out a diagram of the relationships between <code>ip-&gt;addrs[]</code>, the indirect block, the doubly-indirect block and the singly-indirect blocks it points to, and data blocks. Make sure you understand why adding a doubly-indirect block increases the maximum file size by 256*256 blocks (really -1, since you have to decrease the number of direct blocks by one).</li>
<li>Think about how you’ll index the doubly-indirect block, and the indirect blocks it points to, with the logical block number.</li>
<li>If you change the definition of <code>NDIRECT</code>, you’ll probably have to change the declaration of <code>addrs[]</code> in <code>struct inode</code> in <code>file.h</code>. Make sure that <code>struct inode</code> and <code>struct dinode</code> have the same number of elements in their <code>addrs[]</code> arrays.</li>
<li>If you change the definition of <code>NDIRECT</code>, make sure to create a new <code>fs.img</code>, since <code>mkfs</code> uses <code>NDIRECT</code> to build the file system.</li>
<li>If your file system gets into a bad state, perhaps by crashing, delete <code>fs.img</code> (do this from Unix, not xv6). <code>make</code> will build a new clean file system image for you.</li>
<li>Don’t forget to <code>brelse()</code> each block that you <code>bread()</code>.</li>
<li>You should allocate indirect blocks and doubly-indirect blocks only as needed, like the original <code>bmap()</code>.</li>
<li>Make sure <code>itrunc</code> frees all blocks of a file, including double-indirect blocks.</li>
</ul>
</li>
<li>
<p>步骤：</p>
<ul>
<li>修改NDIRECT为11，并相应修改dinode和inode结构体</li>
<li>修改一个文件的最多块数：MAXFILE</li>
<li>修改bmap和itrunc</li>
</ul>
</li>
</ul>
<h3 id="2-Symbolic-links-moderate">2. Symbolic links (<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/6.828/2020/labs/guidance.html">moderate</a>)</h3>
<ul>
<li>
<p>问题：在本练习中，您将向 xv6添加符号链接。符号链接(或软链接)通过路径名称引用链接文件; 当打开一个符号链接时，内核会跟随指向引用文件的链接。符号链接类似于硬链接，但硬链接仅限于指向同一磁盘上的文件，而符号链接可以跨磁盘设备。尽管 xv6不支持多个设备，但是实现这个系统调用是了解路径名查找如何工作的一个很好的练习。</p>
<p><img src="/img/xv6/image-20221215141355827.png" srcset="/img/loading.gif" lazyload alt="image-20221215141355827"></p>
</li>
<li>
<p>任务：You will implement the <code>symlink(char *target, char *path)</code> system call, which creates a new symbolic link at path that refers to file named by target. For further information, see the man page symlink. To test, add symlinktest to the Makefile and run it. Your solution is complete when the tests produce the following output (including usertests succeeding).</p>
</li>
<li>
<p>hints：</p>
<ul>
<li>First, create a new system call number for symlink, add an entry to user/usys.pl, user/user.h, and implement an empty sys_symlink in kernel/sysfile.c.</li>
<li>Add a new file type (<code>T_SYMLINK</code>) to kernel/stat.h to represent a symbolic link.</li>
<li>Add a new flag to kernel/fcntl.h, (<code>O_NOFOLLOW</code>), that can be used with the <code>open</code> system call. Note that flags passed to <code>open</code> are combined using a bitwise OR operator, so your new flag should not overlap with any existing flags. This will let you compile user/symlinktest.c once you add it to the Makefile.</li>
<li>Implement the <code>symlink(target, path)</code> system call to create a new symbolic link at path that refers to target. Note that target does not need to exist for the system call to succeed. You will need to choose somewhere to store the target path of a symbolic link, for example, in the inode’s data blocks. <code>symlink</code> should return an integer representing success (0) or failure (-1) similar to <code>link</code> and <code>unlink</code>.</li>
<li>Modify the <code>open</code> system call to handle the case where the path refers to a symbolic link. If the file does not exist, <code>open</code> must fail. When a process specifies <code>O_NOFOLLOW</code> in the flags to <code>open</code>, <code>open</code> should open the symlink (and not follow the symbolic link).</li>
<li>If the linked file is also a symbolic link, you must recursively follow it until a non-link file is reached. If the links form a cycle, you must return an error code. You may approximate this by returning an error code if the depth of links reaches some threshold (e.g., 10).</li>
<li>Other system calls (e.g., link and unlink) must not follow symbolic links; these system calls operate on the symbolic link itself.</li>
<li>You do not have to handle symbolic links to directories for this lab.</li>
</ul>
</li>
<li>
<p>其实只需要修改sys_open和sys_symlink函数，注意事项hints已列出，其余在代码中也有注释</p>
</li>
</ul>
<h3 id="3-make-grade">3. make grade</h3>
<ul>
<li><strong>注意make grade的bigfile测试会很慢，如果qemu里能通过但make grade时timeout，记得修改grade-lab-fs的timeout参数</strong></li>
<li><img src="/img/xv6/image-20221215151646981.png" srcset="/img/loading.gif" lazyload alt="image-20221215151646981"></li>
</ul>
<h2 id="Lab-Mmap">Lab Mmap</h2>
<ul>
<li>
<p>问题：Mmap 和 munmap 系统调用允许 UNIX 程序对其地址空间进行详细的控制。它们可以用来在进程之间共享内存，<strong>将文件映射到进程地址空间</strong>，以及作为用户级页面错误方案的一部分，如本课讨论的垃圾收集算法。在这个实验中，您将向 xv6添加 mmap 和 munmap，重点是内存映射文件。</p>
<ul>
<li><strong>mmap()系统调用使得进程之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read()，write（）等操作。</strong><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/mmap/1322217?fr=aladdin">Mmap</a></li>
</ul>
</li>
<li>
<p>任务：实现mmap和munmap两个系统调用：</p>
<ul>
<li>
<p><strong>mmap()系统调用</strong>：<code>void* mmap ( void *addr, int length, int prot , int flags, int fd, int offset )</code></p>
<p>参数fd为即将映射到进程空间的文件描述字，一般由open()返回。length是映射到调用进程地址空间的字节数，它从被映射文件开头offset个字节开始算起（<strong>本次实验可假设为0</strong>）。prot 参数指定共享内存的访问权限。可取如下几个值的或：<strong>PROT_READ（可读） , PROT_WRITE （可写）</strong>, （PROT_EXEC （可执行）, PROT_NONE（不可访问））。flags由以下几个常值指定：<strong>MAP_SHARED , MAP_PRIVATE</strong>，其中，MAP_SHARED , MAP_PRIVATE必选其一。offset参数一般设为0（<strong>本实验假设为0</strong>），表示从文件头开始映射。参数addr指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。函数的返回值为最后文件映射到进程空间的地址，进程可直接操作起始地址为该值的有效地址。(失败则返回0xffffffffffffffff )</p>
</li>
<li>
<p><strong>系统调用munmap()</strong>：<code>int munmap( void * addr, int length )</code></p>
<p>该调用在进程地址空间中解除一个映射关系，addr是调用mmap()时返回的地址，length是映射区的大小。当映射关系解除后，对原来映射地址的访问将导致段错误发生。如果进程修改了内存并映射了 MAP _ SHARED，那么修改应该首先写到文件中。Munmap 调用可能只覆盖 mmap-ed 区域的一部分，但是您可以假定它将在开始、结束或整个区域取消映射(<strong>但是不会在区域的中间打一个洞</strong>)。</p>
</li>
</ul>
</li>
<li>
<p>hints</p>
<ul>
<li>
<p>Start by adding <code>_mmaptest</code> to <code>UPROGS</code>, and <code>mmap</code> and <code>munmap</code> system calls, in order to get <code>user/mmaptest.c</code> to compile. For now, just return errors from <code>mmap</code> and <code>munmap</code>. We defined <code>PROT_READ</code> etc for you in <code>kernel/fcntl.h</code>. Run <code>mmaptest</code>, which will fail at the first mmap call.（配置好mmaptest.c，和mmap、munmap系统调用）</p>
</li>
<li>
<p>Fill in the page table lazily, in response to page faults. That is, <code>mmap</code> should not allocate physical memory or read the file. Instead, do that in page fault handling code in (or called by) <code>usertrap</code>, as in the lazy page allocation lab. The reason to be lazy is to ensure that <code>mmap</code> of a large file is fast, and that <code>mmap</code> of a file larger than physical memory is possible.（和lazy的实验一样，采用惰性分配）</p>
</li>
<li>
<p>Keep track of what <code>mmap</code> has mapped for each process. Define a structure corresponding to the VMA (virtual memory area) described in Lecture 15, recording the address, length, permissions, file, etc. for a virtual memory range created by <code>mmap</code>. Since the xv6 kernel doesn’t have a memory allocator in the kernel, it’s OK to declare a fixed-size array of VMAs and allocate from that array as needed. A size of 16 should be sufficient.（跟踪 mmap 为每个进程映射的内容。定义一个与VMA (虚拟内存区域)相对应的结构，记录 mmap 创建的虚拟内存范围的地址、长度、权限、文件等。数组长度可设为16）</p>
</li>
<li>
<p>Implement <code>mmap</code>: find an unused region in the process’s address space in which to map the file, and add a VMA to the process’s table of mapped regions. The VMA should contain a pointer to a <code>struct file</code> for the file being mapped; <code>mmap</code> should increase the file’s reference count so that the structure doesn’t disappear when the file is closed (hint: see <code>filedup</code>). Run <code>mmaptest</code>: the first <code>mmap</code> should succeed, but the first access to the mmap-ed memory will cause a page fault and kill <code>mmaptest</code>.</p>
</li>
<li>
<p>Add code to cause a page-fault in a mmap-ed region to allocate a page of physical memory, read 4096 bytes of the relevant file into that page, and map it into the user address space. Read the file with <code>readi</code>, which takes an offset argument at which to read in the file (but you will have to lock/unlock the inode passed to <code>readi</code>). Don’t forget to set the permissions correctly on the page. Run <code>mmaptest</code>; it should get to the first <code>munmap</code>.</p>
<p>添加代码以导致 mmap-ed 区域中的页错误，从而分配一页物理内存，将相关文件的4096字节读入该页，并将其映射到用户地址空间。使用 readi 读取文件，它接受一个要读入文件的偏移量参数(但是您必须锁定/解锁传递给 readi 的 inode)。不要忘记正确设置页面上的权限。运行 mmaptest; 它应该到达第一个 munmap。</p>
</li>
<li>
<p>Implement <code>munmap</code>: find the VMA for the address range and unmap the specified pages (hint: use <code>uvmunmap</code>). If <code>munmap</code> removes all pages of a previous <code>mmap</code>, it should decrement the reference count of the corresponding <code>struct file</code>. If an unmapped page has been modified and the file is mapped <code>MAP_SHARED</code>, write the page back to the file. Look at <code>filewrite</code> for inspiration.</p>
<p>实现 munmap: 找到地址范围的 VMA 并取消映射指定的页面(提示: 使用 uvmunmap)。如果 munmap 删除了一个 mmap 的所有页面，那么它应该递减相应结构文件的引用计数。如果一个未映射的页面已被修改，并且该文件已被映射为 MAP _ SHARED，则将该页面写回该文件。从filewrite中寻找灵感。</p>
</li>
<li>
<p>Ideally your implementation would only write back <code>MAP_SHARED</code> pages that the program actually modified. The dirty bit (<code>D</code>) in the RISC-V PTE indicates whether a page has been written. However, <code>mmaptest</code> does not check that non-dirty pages are not written back; thus you can get away with writing pages back without looking at <code>D</code> bits.</p>
<p>理想情况下，您的实现将只写回程序实际修改过的 MAP _ SHARED 页面。RISC-V PTE 中的脏位(D)表示页是否已被写入。然而，mmaptest 不检查非脏页面是否没有被写回; 因此您可以不查看 D 位就可以写回页面。</p>
</li>
<li>
<p>Modify <code>exit</code> to unmap the process’s mapped regions as if <code>munmap</code> had been called. Run <code>mmaptest</code>; <code>mmap_test</code> should pass, but probably not <code>fork_test</code>.</p>
<p>exit时，取消一个进程所有vma的所有区域的映射</p>
</li>
<li>
<p>Modify <code>fork</code> to ensure that the child has the same mapped regions as the parent. Don’t forget to increment the reference count for a VMA’s <code>struct file</code>. In the page fault handler of the child, it is OK to allocate a new physical page instead of sharing a page with the parent. The latter would be cooler, but it would require more implementation work. Run <code>mmaptest</code>; it should pass both <code>mmap_test</code> and <code>fork_test</code>.</p>
<p>为子进程同步父进程所有vma的所有区域的映射, 类似mmap，同时注意文件引用计数</p>
</li>
</ul>
</li>
<li>
<p>步骤：</p>
<ul>
<li>配置好mmaptest.c，和mmap、munmap系统调用</li>
<li>声明结构体VMA，以其为元素声明长度为16的数组，在进程控制块增加p-&gt;curmax用于记录最高空间地址；p-&gt;vmalist用于记录该进程中对mmap的各条记录</li>
<li>创建辅助函数
<ul>
<li>initvma</li>
<li>allocvma</li>
<li>deallocvma</li>
</ul>
</li>
<li>完成mmap系统调用：
<ul>
<li><a target="_blank" rel="noopener" href="https://xiayingp.gitbook.io/build_a_os/labs/untitled#how-to-determine-vma-start-and-end-address">How to determine VMA start and end address</a></li>
<li><img src="/img/xv6/image-20221024160039840.png" srcset="/img/loading.gif" lazyload alt="image-20221024160039840"></li>
</ul>
</li>
<li>由于惰性分配，处理页面错误</li>
<li>完成munmap系统调用：</li>
<li>完成fork中子进程同步父进程的vma（注意文件引用计数）</li>
<li>完成exit中vma解除映射（注意文件引用计数）</li>
</ul>
</li>
<li>
<p><img src="/img/xv6/image-20221216133907508.png" srcset="/img/loading.gif" lazyload alt="image-20221216133907508"></p>
</li>
</ul>
<h2 id="Book">Book</h2>
<h3 id="调度的一部分总结（sleep-and-wakeup）">调度的一部分总结（sleep and wakeup）</h3>
<p><a target="_blank" rel="noopener" href="http://xv6.dgs.zone/tranlate_books/book-riscv-rev1/c7/s5.html">调度</a></p>
<p><img src="/img/xv6/image-20221213112534209.png" srcset="/img/loading.gif" lazyload alt="image-20221213112534209"></p>
<h3 id="操作inode的过程">操作inode的过程</h3>
<ul>
<li>ip = iget(dev, inum)
<ul>
<li>获取内存inode，引用次数加1，此时inode可能还未从磁盘读取。（多个进程可以持有指向<code>iget</code>返回的inode的C指针，但一次只能有一个进程锁定inode）</li>
</ul>
</li>
<li>ilock(ip)
<ul>
<li>为ip上睡眠锁，若inode.valid为0，则从磁盘读取inode到ip</li>
</ul>
</li>
<li>… examine and modify ip-&gt;xxx …</li>
<li>iunlock(ip)
<ul>
<li>为ip解除睡眠锁</li>
</ul>
</li>
<li>iput(ip)
<ul>
<li>引用次数减1，如果是最后一次引用，且没有链接指向inode，则释放inode（在磁盘上）。itrunc()清理(将文件截断为0字节，同时释放各块)、iupdate()写回磁盘</li>
<li><code>iput()</code>不会在文件的链接计数降至零时立即截断文件，因为某些进程可能仍在内存中保留对inode的引用。这可能导致磁盘上存在links为0，但却已被分配（type不为0）的文件。xv6没有解决这个问题，可能会导致磁盘空间不足</li>
</ul>
</li>
</ul>
<h4 id="其它函数">其它函数</h4>
<ul>
<li><code>struct inode*ialloc(uint dev, short type)</code>：Allocate an inode on device dev.Mark it as allocated by  giving it type type.Returns an unlocked but allocated and referenced inode
<ul>
<li><code>ialloc</code>的正确操作取决于这样一个事实：一次只有一个进程可以保存对<code>bp</code>的引用：<code>ialloc</code>可以确保其他进程不会同时看到inode可用并尝试声明它</li>
</ul>
</li>
<li><code>bmap(struct inode *ip, uint bn)</code>返回索引结点<code>ip</code>的第<code>bn</code>个数据块的磁盘块号。如果<code>ip</code>还没有这样的块，<code>bmap</code>会分配一个</li>
<li><code>int readi(struct inode *ip, int user_dst, uint64 dst, uint off, uint n)</code>：Read data from inode . Caller must hold ip-&gt;lock. If user_dst==1, then dst is a user virtual address; otherwise, dst is a kernel address.</li>
<li><code>int writei(struct inode *ip, int user_src, uint64 src, uint off, uint n)</code>：Write data to inode. Caller must hold ip-&gt;lock. If user_src==1, then src is a user virtual address; otherwise, src is a kernel address. Returns the number of bytes successfully written. If the return value is less than the requested n, there was an error of some kind.</li>
<li>函数<code>stati</code>（*<strong>kernel/fs.c*</strong>:442）将inode元数据复制到<code>stat</code>结构体中，该结构通过<code>stat</code>系统调用向用户程序公开</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/labs/">#labs</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>xv6</div>
      <div>https://lai-jx.github.io/2023/01/15/xv6/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Jiaxin Lai</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年1月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/01/14/%E5%9F%BA%E7%A1%80%E7%AF%87/" title="基础篇">
                        <span class="hidden-mobile">基础篇</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="waline"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#waline', function() {
      Fluid.utils.createCssLink('https://lib.baomitu.com/waline/2.14.1/waline.min.css')
      Fluid.utils.createScript('https://lib.baomitu.com/waline/2.14.1/waline.min.js', function() {
        var options = Object.assign(
          {"serverURL":"https://waline-blog-lai-jx.vercel.app/","path":"window.location.pathname","meta":["nick","mail","link"],"requiredMeta":["nick"],"lang":"zh-CN","emoji":["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],"dark":"html[data-user-color-scheme=\"dark\"]","wordLimit":0,"pageSize":10},
          {
            el: '#waline',
            path: window.location.pathname
          }
        )
        Waline.init(options);
        Fluid.utils.waitElementVisible('#waline .vcontent', () => {
          var imgSelector = '#waline .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
